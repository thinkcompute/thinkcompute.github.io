(ch-preface)=
# Try. Make mistakes. Learn. Repeat.

I want to start with a clear disclosure: the main aim of this book is to introduce three specific Computer Science topics - namely **Computational Thinking**, **Programming**, and **Data Management** - to students **in the Humanities** with **no prior knowledge** of them. In particular, the book presents the _essential_ and _practical_ aspects of these topics – abstraction, algorithms, data structures, programming languages, data models, and databases - which are among the primary knowledge, methods, and tools characterising Computer Science as a discipline. 

The idea behind writing this book came from the need to provide a free textbook to the students of the Computational Thinking and Programming course (now included in the [*Computational Management of Data*](https://www.unibo.it/it/studiare/insegnamenti-competenze-trasversali-moocs/insegnamenti/insegnamento/2025/542133) course) for the [Second Cycle Degree in Digital Humanities and Digital Knowledge](https://corsi.unibo.it/2cycle/DigitalHumanitiesKnowledge) at the [University of Bologna](https://www.unibo.it). The topics this book introduces are usually delivered in four or five courses of a standard Computer Science Bachelor degree. I organised its chapters to provide enough tools for students to enable them to start their computationally related careers within a Digital Humanities (DH) curriculum. As you can imagine, with the constraints of a 30-hour course to introduce these topics, there is no space for an in-depth presentation of all the philosophical aspects of computational thinking and other computer science topics in general. However, each chapter provides pointers to enable curious students to explore and increase their knowledge on these topics – something that students in the Humanities can do brilliantly.

Another essential clarification: this is _not_ a book about Python. As you may have noticed, no word for "Python" is in its title. The book is meant to introduce how to use a _language_ to _communicate with_ and _instruct_ an information-processing agent (be it a human or a machine), which is one of the core tasks of Computational Thinking. In particular, the book presents general notions and methods – namely _algorithms_, _data structures_, and _algorithmic techniques_. Computer Science degrees are usually introduced using [pseudocode](https://en.wikipedia.org/wiki/Pseudocode), i.e. an informal and high-level description (generally for human consumption only) of the steps of an algorithm and the methods that characterise the operations of data structures. Programming languages enter the game when we want to instruct an electronic computer in dealing with these aspects.

After an initial presentation of flowcharts as a language to devise algorithms, the book adopts Python as a _representative language_ to interact with an information-processing agent. I chose Python in this context due to its current use in real-world projects, particularly those related to the Humanities. Of course, several Python-related notions are briefly introduced in the book since they are functional for understanding the topic presented in each chapter. However, these notions are generalisable in any programming language despite how Python implements them. Therefore, it is up to the students to get more in-depth knowledge about Python (if needed) by reading one of the free Python books suggested in Chapter {ref}`ch-programming-languages`, such as the wonderful ["How To Code in Python"](https://www.digitalocean.com/community/books/digitalocean-ebook-how-to-code-in-python) by [Lisa Tagliaferri](https://twitter.com/lisaironcutter).

The book introduces all the relevant topics mentioned above – algorithms, data structures, and algorithmic techniques (i.e. the methods of computing), exemplified by using a particular programming language (i.e. Python) – by iterating on basic _computational problems_ (find an item in a collection, sorting a list of items, solving a solitaire, etc.). Sometimes, the book addresses the same computational problem with different techniques to show how it is possible to provide better solutions to it (e.g. more efficient strategies in terms of time/resources spent to address the problem) depending on some specific premises.

Students often need help on computational topics at the beginning of their learning path. Questions like "From where do I have to start to develop an algorithm?" and "How can I check whether an algorithm does what I want?" arise when students approach algorithms for the first time. Thus, to support students, the book devises a development methodology for algorithms and their formal implementation using a programming language that recalls the well-known _test-driven development_ technique in Software Engineering. While such a methodology answers the questions above, it also introduces good software development practices. In principle, adopting such a methodology and applying the methods of computing mentioned above enables students to write a piece of work (either an algorithm or an entire software) that is efficient, effective, robust, and maintainable in the long term.

As anticipated, this book is a textbook. Thus, all the chapters are accompanied by exercises to practice the topics introduced. The keys to these exercises are available on the book's website at [https://comp-data.github.io](https://comp-data.github.io) and are organised by chapter. Also, the website includes additional exercises that focus on enhancing the two main activities concerning learning a new language: _understanding_ something written in a specific language and using such a language to _develop_ new work. Remember: there can be different ways to solve an exercise, and the solutions provided present _one_ possible way.

In addition to exercises, several of the initial chapters briefly describe a "historic hero" who is functional to discuss the main topic addressed in those chapters. These heroes are not necessarily computer scientists. Indeed, some of them are even writers. The book uses them to show that essential aspects such as computation, data structures, and recursion (a fascinating concept I did not introduce in this preface that characterises our daily lives) can be found where they are not usually expected. Of course, this is not an original idea at all. The use of people outside the Computer Science domain to introduce Computer Science topics has already been adopted in the past. It is instrumental in presenting such issues to a varied audience.

Sometimes, it happens to hear whispers of despair like "algorithms, computations, programming, etc., are something which I cannot handle – indeed, I did not like mathematics at the high school", "I am not able to abstract a situation by using formal tools since I am not a formal person", and even "I cannot learn a programming language". These are just **prejudices**. First, the book introduces several things that all of us learned and digested in our experience. It is only a matter of identifying them again to reuse them consciously. Second, we have a growth mindset. Intelligence is a muscle, it can be developed, and yes: we can learn anything if we truly want to, including Computer Science topics, despite what others say. Third, a programming language _is _a language like Italian and English. To properly handle a language, we need time and practice. Trying, making mistakes, correcting misuses, and talking with others who are more fluent than us in that language is critical to learning it properly. Programming languages are no exception. 

Let me conclude with a final motto from a famous movie that describes the right attitude to adopt when addressing the topics of this book: 

> Anyone can cook, but only the fearless can be great. 

Try. Make mistakes. Learn. Repeat.